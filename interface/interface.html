<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orchestrateur Docker Intelligent</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 14px;
            font-size: 14px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.15em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 18px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.25em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 13px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            width: 100%;
            margin-top: 10px;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .container-list {
            list-style: none;
        }

        .container-item {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .container-item strong {
            color: #667eea;
        }

        .status-badge {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-running {
            background: #d4edda;
            color: #155724;
        }

        .status-stopped {
            background: #f8d7da;
            color: #721c24;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .metric-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px;
            border-radius: 10px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.6em;
            font-weight: bold;
            margin: 10px 0;
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        #graphCanvas {
            width: 100% !important;
            height: 360px !important;
            background: white;
            border-radius: 10px;
            padding: 20px;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .relation-list {
            list-style: none;
        }

        .relation-item {
            background: #e9ecef;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            font-family: monospace;
        }

        .graph-toolbar {
            display: none;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 10px;
        }

        .graph-toolbar button {
            width: auto;
            margin-top: 0;
            padding: 10px 14px;
            font-size: 14px;
        }

        .graph-toolbar select {
            width: auto;
            min-width: 180px;
        }

        .graph-toolbar .danger {
            background: #dc3545;
        }

        .graph-toolbar .secondary {
            background: #6c757d;
        }

        .graph-status {
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #444;
        }

        .graph-actions {
            margin-top: 10px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.08);
            border: 1px solid rgba(102, 126, 234, 0.25);
            border-radius: 10px;
        }

        .graph-actions-row {
            display: flex;
            flex-wrap: wrap;
        }

        .graph-context-menu {
            position: fixed;
            z-index: 9999;
            display: none;
            min-width: 260px;
            max-width: 360px;
            padding: 10px;
            background: #fff;
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        }

        .graph-context-title {
            font-family: monospace;
            font-size: 12px;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .graph-context-title button {
            width: auto;
            margin: 0;
            padding: 6px 10px;
            font-size: 12px;
            background: #6c757d;
        }

        .graph-context-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .graph-context-row button {
            width: auto;
            margin-top: 0;
            padding: 10px 12px;
            font-size: 13px;
        }

        .graph-context-row .danger {
            background: #dc3545;
        }

        .graph-context-row .secondary {
            background: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🐳 Orchestrateur Docker Intelligent</h1>

        <div class="dashboard">

            <!-- Liste des conteneurs -->
            <div class="card">
                <h2>📦 Conteneurs Actifs</h2>
                <button onclick="refreshContainers()" style="margin-bottom: 15px;">🔄 Actualiser</button>
                <ul class="container-list" id="containersList"></ul>
            </div>

            <!-- Métriques globales -->
            <div class="card">
                <h2>📊 Métriques Globales</h2>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-label">Conteneurs Actifs</div>
                        <div class="metric-value" id="totalContainers">0</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Relations</div>
                        <div class="metric-value" id="totalRelations">0</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Événements Scaling</div>
                        <div class="metric-value" id="scalingEvents">0</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Charge Moyenne</div>
                        <div class="metric-value" id="avgLoad">0%</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>🧪 Évaluation</h2>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-label">Throughput</div>
                        <div class="metric-value" id="evalThroughput">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Error Rate</div>
                        <div class="metric-value" id="evalErrorRate">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Latency mean</div>
                        <div class="metric-value" id="evalLatencyMean">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Latency p95</div>
                        <div class="metric-value" id="evalLatencyP95">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Latency p99</div>
                        <div class="metric-value" id="evalLatencyP99">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">CPU avg</div>
                        <div class="metric-value" id="evalCpuAvg">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Memory avg</div>
                        <div class="metric-value" id="evalMemAvg">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Memory peak</div>
                        <div class="metric-value" id="evalMemPeak">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Replicas (actuels)</div>
                        <div class="metric-value" id="evalReplicas">-</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Scaling (derniers 50)</div>
                        <div class="metric-value" id="evalScaling">-</div>
                    </div>
                </div>
                <div class="graph-status" style="margin-top: 10px; display:flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <label style="display:flex; gap: 8px; align-items:center; margin: 0; font-weight: 600;">
                        <input type="checkbox" id="demoMetricsToggle">
                        Mode démo (simulé)
                    </label>
                    <div id="evalStatus" style="font-family: monospace; font-size: 12px; color: #444;">Source: -</div>
                </div>
            </div>

            <div class="card">
                <h2>⚡ Générer un Flux</h2>
                <div class="form-group">
                    <label>Cible:</label>
                    <select id="trafficTarget">
                        <option value="">-- Choisir un conteneur --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>RPS (requêtes / seconde):</label>
                    <input type="number" id="trafficRps" min="0" step="1" value="10">
                </div>
                <div class="form-group">
                    <label>Complexité:</label>
                    <input type="number" id="trafficComplexity" min="1" step="1" value="5">
                </div>
                <div class="form-group">
                    <label>Durée (secondes) - optionnel:</label>
                    <input type="number" id="trafficDuration" min="1" step="1" placeholder="ex: 30">
                </div>
                <button onclick="startTraffic()">Démarrer le flux</button>
                <button onclick="stopTraffic()" style="margin-top: 10px; background: #dc3545;">Arrêter le flux</button>
                <div id="trafficAlert"></div>
                <div style="margin-top: 10px; font-family: monospace; font-size: 12px; color: #444;">
                    <div>Job: <span id="trafficJobId">-</span></div>
                    <div>Envoyées: <span id="trafficSent">0</span></div>
                    <div>Erreurs: <span id="trafficErrors">0</span></div>
                    <div>Running: <span id="trafficRunning">false</span></div>
                    <div>Dernière cible: <span id="trafficLastTarget">-</span></div>
                    <div>Dernier status: <span id="trafficLastStatus">-</span></div>
                    <div>Dernière erreur: <span id="trafficLastError">-</span></div>
                </div>
            </div>

            <!-- Graphe de dépendances -->
            <div class="card" style="margin-bottom: 20px;">
                <h2>🌐 Graphe de Dépendances</h2>
                <canvas id="graphCanvas"></canvas>
                <div id="graphAlert"></div>
                <div class="graph-status" id="graphStatus">Mode: sélection</div>
                <div class="graph-actions" id="graphActions">
                    <div class="graph-actions-title" id="graphSelectionText">Sélection: aucune</div>
                    <div class="graph-actions-row">
                        <button class="secondary" onclick="startAddLinkFromSelected()">+ relation</button>
                        <button class="secondary" onclick="startRemoveLinkFromSelected()">- relation</button>
                        <button onclick="createContainerLinkedFromSelected()">+ conteneur</button>
                        <button class="danger" onclick="deleteSelectedFromGraph()">Supprimer conteneur</button>
                        <button class="danger" onclick="removeSelectedEdgeFromGraph()">Supprimer lien sélectionné</button>
                    </div>
                    <div class="graph-actions-title" id="graphHintText" style="margin-top: 8px;">Astuce: clique un node pour le sélectionner.</div>
                </div>

                <div class="graph-context-menu" id="graphContextMenu">
                    <div class="graph-context-title">
                        <div id="graphContextTitle">Sélection</div>
                        <button type="button" onclick="hideGraphContextMenu()">Fermer</button>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <select id="graphContextRelationType">
                            <option value="depends_on">Dépend de</option>
                            <option value="communicates_with">Communique avec</option>
                            <option value="uses">Utilise</option>
                            <option value="master_of">Master → Worker</option>
                            <option value="replica_of">Replica → Parent</option>
                        </select>
                    </div>
                    <div class="graph-context-row" id="graphContextNodeActions">
                        <button class="secondary" type="button" onclick="startAddLinkFromSelected()">+ relation</button>
                        <button class="secondary" type="button" onclick="startRemoveLinkFromSelected()">- relation</button>
                        <button type="button" onclick="createContainerLinkedFromSelected()">+ conteneur</button>
                        <button class="danger" type="button" onclick="deleteSelectedFromGraph()">Supprimer conteneur</button>
                    </div>
                    <div class="graph-context-row" id="graphContextEdgeActions" style="display:none; margin-top: 8px;">
                        <button class="danger" type="button" onclick="removeSelectedEdgeFromGraph()">Supprimer lien</button>
                    </div>
                </div>
            </div>

            <!-- Graphiques de monitoring -->
            <div class="card">
                <h2>📈 Monitoring en Temps Réel</h2>
                <div class="form-group">
                    <label>Sélectionner un conteneur:</label>
                    <select id="monitorContainer">
                        <option value="">-- Choisir un conteneur --</option>
                    </select>
                </div>
                <div class="chart-container">
                    <canvas id="metricsChart"></canvas>
                </div>
                <div class="graph-status" id="monitorStatus">-</div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:5000';
        let metricsChart = null;
        let relations = [];
        let currentTrafficJobId = null;
        let graphData = null;

        let currentMonitoredContainer = null;
        let monitorRefreshTimer = null;

        let graphMode = 'select';
        let graphLinkFrom = null;
        let selectedNodeId = null;
        let selectedEdge = null; // {from,to,type}
        let nodeHitBoxes = new Map();
        let edgeHitLines = [];

        let graphContextOpen = false;

        let graphPositionsLoaded = false;
        const graphPositionsStorageKey = 'graphNodePositions_v1';
        let graphPositions = new Map();

        let graphDraggingNodeId = null;
        let graphDragOffset = {x: 0, y: 0};
        let graphDragMoved = false;
        let graphSuppressNextClick = false;
        let graphShiftLinkFrom = null;
        let graphShiftLinkPoint = null;
        let graphPointerDownPoint = null;
        let graphPointerDownNodeId = null;

        function ensureGraphPositionsLoaded() {
            if (graphPositionsLoaded) return;
            graphPositionsLoaded = true;
            try {
                const raw = localStorage.getItem(graphPositionsStorageKey);
                if (!raw) return;
                const obj = JSON.parse(raw);
                if (!obj || typeof obj !== 'object') return;
                for (const [k, v] of Object.entries(obj)) {
                    if (!v || typeof v !== 'object') continue;
                    const x = Number(v.x);
                    const y = Number(v.y);
                    if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
                    graphPositions.set(String(k), {x, y});
                }
            } catch (e) {
            }
        }

        function saveGraphPositions() {
            try {
                const obj = {};
                for (const [k, v] of graphPositions.entries()) {
                    if (!v) continue;
                    obj[String(k)] = {x: Number(v.x), y: Number(v.y)};
                }
                localStorage.setItem(graphPositionsStorageKey, JSON.stringify(obj));
            } catch (e) {
            }
        }

        // Créer un conteneur
        async function createContainer() {
            const name = document.getElementById('containerName').value;
            const image = document.getElementById('containerImage').value;
            const envText = document.getElementById('containerEnv').value;
            
            let env = {};
            if (envText) {
                try {
                    env = JSON.parse(envText);
                } catch (e) {
                    showAlert('createAlert', 'Erreur: JSON invalide', 'error');
                    return;
                }
            }

            try {
                const response = await fetch(`${API_URL}/container/create`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name, image, env})
                });
                
                const result = await response.json();
                showAlert('createAlert', `✅ Conteneur créé: ${name}`, 'success');
                refreshContainers();
                updateMonitorSelect();
            } catch (error) {
                showAlert('createAlert', `❌ Erreur: ${error.message}`, 'error');
            }
        }

        // Ajouter une relation
        async function addRelation() {
            const from = document.getElementById('relationFrom').value;
            const to = document.getElementById('relationTo').value;
            const type = document.getElementById('relationType').value;

            try {
                const response = await fetch(`${API_URL}/relation/add`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({from, to, type})
                });
                
                showAlert('relationAlert', '✅ Relation ajoutée', 'success');
                relations.push({from, to, type});
                updateRelationsList();
                document.getElementById('totalRelations').textContent = relations.length;
            } catch (error) {
                showAlert('relationAlert', `❌ Erreur: ${error.message}`, 'error');
            }
        }

        async function removeRelation() {
            const from = document.getElementById('relationFrom').value;
            const to = document.getElementById('relationTo').value;
            const type = document.getElementById('relationType').value;

            if (!from || !to) {
                showAlert('relationAlert', 'Erreur: from/to manquants', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_URL}/relation/remove`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({from, to, type})
                });

                const result = await response.json();
                if (!response.ok) {
                    showAlert('relationAlert', `❌ Erreur: ${result.error || 'remove failed'}`, 'error');
                    return;
                }

                relations = relations.filter(r => !(r.from === from && r.to === to && r.type === type));
                updateRelationsList();
                document.getElementById('totalRelations').textContent = relations.length;
                showAlert('relationAlert', '🗑️ Relation supprimée', 'success');
            } catch (error) {
                showAlert('relationAlert', `❌ Erreur: ${error.message}`, 'error');
            }
        }

        // Actualiser la liste des conteneurs
        async function refreshContainers() {
            try {
                const response = await fetch(`${API_URL}/containers/list`);
                const data = await response.json();
                
                const list = document.getElementById('containersList');
                list.innerHTML = '';
                
                data.containers.forEach(container => {
                    const li = document.createElement('li');
                    li.className = 'container-item';
                    const replicasCount = (container.replicas || []).length;
                    li.innerHTML = `
                        <strong>${container.name}</strong>
                        <span class="status-badge status-running">Running</span>
                        <span class="replicas-badge">Répliques: ${replicasCount}</span>
                    `;
                    list.appendChild(li);
                });
                
                document.getElementById('totalContainers').textContent = data.containers.length;
            } catch (error) {
                console.error('Erreur:', error);
            }
        }

        // Mettre à jour la liste des relations
        function updateRelationsList() {
            const list = document.getElementById('relationsList');
            list.innerHTML = '';
            
            relations.forEach(rel => {
                const li = document.createElement('li');
                li.className = 'relation-item';
                const safeFrom = String(rel.from).replace(/'/g, "\\'");
                const safeTo = String(rel.to).replace(/'/g, "\\'");
                const safeType = String(rel.type).replace(/'/g, "\\'");
                li.innerHTML = `<span>${rel.from} → ${rel.to} (${rel.type})</span> <button style="margin-left:10px; padding: 4px 8px; background:#dc3545;" onclick="quickRemoveRelation('${safeFrom}','${safeTo}','${safeType}')">Supprimer</button>`;
                list.appendChild(li);
            });
        }

        async function quickRemoveRelation(from, to, type) {
            document.getElementById('relationFrom').value = from;
            document.getElementById('relationTo').value = to;
            document.getElementById('relationType').value = type;
            await removeRelation();
        }

        // Mettre à jour le select de monitoring
        async function updateMonitorSelect() {
            try {
                const response = await fetch(`${API_URL}/containers/list`);
                const data = await response.json();

                const select = document.getElementById('monitorContainer');
                select.innerHTML = '<option value="">-- Choisir un conteneur --</option>';

                data.containers.forEach(container => {
                    const option = document.createElement('option');
                    option.value = container.name;
                    option.textContent = container.name;
                    select.appendChild(option);
                });

                const trafficSelect = document.getElementById('trafficTarget');
                trafficSelect.innerHTML = '<option value="">-- Choisir un conteneur --</option>';
                data.containers.forEach(container => {
                    const option = document.createElement('option');
                    option.value = container.name;
                    option.textContent = container.name;
                    trafficSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Erreur:', error);
            }
        }

        async function startTraffic() {
            const target = document.getElementById('trafficTarget').value;
            const rps = Number(document.getElementById('trafficRps').value || 0);
            const complexity = Number(document.getElementById('trafficComplexity').value || 1);
            const durationText = document.getElementById('trafficDuration').value;
            const duration_seconds = durationText ? Number(durationText) : null;

            if (!target) {
                showAlert('trafficAlert', 'Erreur: cible manquante', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_URL}/traffic/start`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({target, rps, complexity, duration_seconds, direct: true})
                });

                const result = await response.json();
                if (!response.ok) {
                    showAlert('trafficAlert', `❌ Erreur: ${result.error || 'start failed'}`, 'error');
                    return;
                }

                currentTrafficJobId = result.job.id;
                document.getElementById('trafficJobId').textContent = currentTrafficJobId;
                showAlert('trafficAlert', `✅ Flux démarré: ${target}`, 'success');
            } catch (error) {
                showAlert('trafficAlert', `❌ Erreur: ${error.message}`, 'error');
            }
        }

        async function stopTraffic() {
            if (!currentTrafficJobId) {
                showAlert('trafficAlert', 'Erreur: aucun job actif', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_URL}/traffic/stop`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({id: currentTrafficJobId})
                });

                const result = await response.json();
                if (!response.ok) {
                    showAlert('trafficAlert', `❌ Erreur: ${result.error || 'stop failed'}`, 'error');
                    return;
                }

                showAlert('trafficAlert', '🛑 Arrêt demandé', 'success');
            } catch (error) {
                showAlert('trafficAlert', `❌ Erreur: ${error.message}`, 'error');
            }
        }

        async function refreshTrafficStatus() {
            try {
                const response = await fetch(`${API_URL}/traffic/status`);
                const result = await response.json();
                const jobs = result.jobs || [];

                let job = null;
                if (currentTrafficJobId) {
                    job = jobs.find(j => j.id === currentTrafficJobId);
                }

                if (!job && jobs.length > 0 && !currentTrafficJobId) {
                    job = jobs[jobs.length - 1];
                    currentTrafficJobId = job.id;
                    document.getElementById('trafficJobId').textContent = currentTrafficJobId;
                }

                if (job) {
                    document.getElementById('trafficSent').textContent = job.sent;
                    document.getElementById('trafficErrors').textContent = job.errors;
                    document.getElementById('trafficRunning').textContent = job.running;
                    document.getElementById('trafficLastTarget').textContent = job.last_target || '-';
                    document.getElementById('trafficLastStatus').textContent = (job.last_status_code !== null && job.last_status_code !== undefined) ? job.last_status_code : '-';
                    document.getElementById('trafficLastError').textContent = job.last_error || '-';
                }
            } catch (error) {
                showAlert('trafficAlert', `❌ Erreur: ${error.message}`, 'error');
            }
        }

        function formatNumber(value, digits = 2) {
            const n = Number(value);
            if (!Number.isFinite(n)) return '-';
            return n.toFixed(digits);
        }

        function parseIsoToMs(iso) {
            try {
                const ms = Date.parse(String(iso));
                return Number.isFinite(ms) ? ms : null;
            } catch (e) {
                return null;
            }
        }

        function pickLatestJob(jobs) {
            try {
                if (!Array.isArray(jobs) || jobs.length === 0) return null;
                const sorted = jobs.slice().sort((a, b) => {
                    const at = parseIsoToMs(a && a.started_at);
                    const bt = parseIsoToMs(b && b.started_at);
                    return (at || 0) - (bt || 0);
                });
                return sorted[sorted.length - 1];
            } catch (e) {
                return null;
            }
        }

        async function fetchJsonOrNull(url) {
            try {
                const resp = await fetch(url);
                const data = await resp.json();
                return {ok: resp.ok, status: resp.status, data};
            } catch (e) {
                return {ok: false, status: 0, data: null, error: e};
            }
        }

        function setEvalStatus(text) {
            const el = document.getElementById('evalStatus');
            if (el) el.textContent = text;
        }

        function setEvalText(id, text) {
            const el = document.getElementById(id);
            if (el) el.textContent = text;
        }

        function setMonitorStatus(text) {
            const el = document.getElementById('monitorStatus');
            if (el) el.textContent = text;
        }

        function buildEmptyChart() {
            const canvas = document.getElementById('metricsChart');
            if (!canvas) return null;
            const ctx = canvas.getContext('2d');
            if (!ctx) return null;

            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'CPU %',
                            data: [],
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.15)',
                            tension: 0.25,
                            fill: true
                        },
                        {
                            label: 'Mémoire %',
                            data: [],
                            borderColor: '#764ba2',
                            backgroundColor: 'rgba(118, 75, 162, 0.10)',
                            tension: 0.25,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: 100
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        }
                    }
                }
            });
        }

        function initMetricsChart() {
            try {
                if (!metricsChart) {
                    metricsChart = buildEmptyChart();
                }
            } catch (e) {
                metricsChart = null;
            }

            const select = document.getElementById('monitorContainer');
            if (select) {
                select.addEventListener('change', async () => {
                    currentMonitoredContainer = select.value || null;
                    await refreshSelectedContainerMetrics(true);
                });
            }

            if (!monitorRefreshTimer) {
                monitorRefreshTimer = setInterval(() => {
                    refreshSelectedContainerMetrics(false);
                }, 2000);
            }

            refreshSelectedContainerMetrics(true);
        }

        function renderDemoMonitoringSeries() {
            if (!metricsChart) return;
            const now = Date.now();
            const labels = [];
            const cpu = [];
            const mem = [];
            for (let i = 19; i >= 0; i--) {
                const t = new Date(now - i * 1000);
                labels.push(t.toLocaleTimeString('fr-FR'));
                const wave = (Math.sin((now / 1000 - i) / 6) + 1) / 2;
                const wave2 = (Math.sin((now / 1000 - i) / 3.5 + 1.3) + 1) / 2;
                cpu.push(35 + 25 * wave);
                mem.push(25 + 18 * wave2);
            }

            metricsChart.data.labels = labels;
            metricsChart.data.datasets[0].data = cpu;
            metricsChart.data.datasets[1].data = mem;
            metricsChart.update();
            setMonitorStatus('Monitoring: demo (simulé)');
        }

        async function refreshSelectedContainerMetrics(force) {
            const select = document.getElementById('monitorContainer');
            const selected = (select && select.value) ? select.value : null;
            currentMonitoredContainer = selected;

            if (!metricsChart) {
                try {
                    metricsChart = buildEmptyChart();
                } catch (e) {
                    metricsChart = null;
                }
            }

            if (!currentMonitoredContainer) {
                if (metricsChart) {
                    metricsChart.data.labels = [];
                    metricsChart.data.datasets[0].data = [];
                    metricsChart.data.datasets[1].data = [];
                    metricsChart.update();
                }
                setMonitorStatus('Monitoring: sélectionne un conteneur');
                return;
            }

            const demo = loadDemoMetricsEnabled();
            const url = `${API_URL}/container/${encodeURIComponent(currentMonitoredContainer)}/metrics`;
            const res = await fetchJsonOrNull(url);
            if (!res.ok) {
                if (demo) {
                    renderDemoMonitoringSeries();
                    return;
                }
                setMonitorStatus(`Monitoring: erreur (${res.status || 'offline'})`);
                return;
            }

            const series = Array.isArray(res.data) ? res.data : [];
            if (!metricsChart) return;

            const labels = [];
            const cpu = [];
            const mem = [];
            series.slice(-20).forEach(m => {
                try {
                    const ts = m && (m.timestamp || m.time || m.t);
                    const label = ts ? String(ts).slice(11, 19) : '';
                    labels.push(label || new Date().toLocaleTimeString('fr-FR'));
                    const c = Number(m && m.cpu_percent);
                    const mm = Number(m && m.memory_percent);
                    cpu.push(Number.isFinite(c) ? c : 0);
                    mem.push(Number.isFinite(mm) ? mm : 0);
                } catch (e) {
                }
            });

            metricsChart.data.labels = labels;
            metricsChart.data.datasets[0].data = cpu;
            metricsChart.data.datasets[1].data = mem;
            metricsChart.update();
            setMonitorStatus(`Monitoring: ${currentMonitoredContainer}`);
        }

        function loadDemoMetricsEnabled() {
            try {
                const raw = localStorage.getItem('demoMetricsEnabled_v1');
                if (raw === '1') return true;
                if (raw === '0') return false;
            } catch (e) {
            }
            return false;
        }

        function setDemoMetricsEnabled(enabled) {
            try {
                localStorage.setItem('demoMetricsEnabled_v1', enabled ? '1' : '0');
            } catch (e) {
            }
        }

        function renderDemoEvaluationMetrics() {
            const t = Date.now() / 1000;
            const wave = (Math.sin(t / 6) + 1) / 2;
            const wave2 = (Math.sin(t / 3.5 + 1.3) + 1) / 2;

            const throughput = 80 + 40 * wave;
            const errRate = 0.05 + 0.25 * (1 - wave2);
            const latMean = 18 + 8 * (1 - wave);
            const latP95 = 45 + 15 * (1 - wave2);
            const latP99 = 85 + 25 * (1 - wave2);
            const cpuAvg = 45 + 18 * wave;
            const memAvg = 30 + 12 * wave2;
            const memPeak = 55 + 10 * wave;

            const replicas = 2;
            const scalingCount = 6;

            setEvalText('evalThroughput', `${formatNumber(throughput, 2)} rps`);
            setEvalText('evalErrorRate', `${formatNumber(errRate, 2)}%`);
            setEvalText('evalLatencyMean', `${formatNumber(latMean, 1)} ms`);
            setEvalText('evalLatencyP95', `${formatNumber(latP95, 1)} ms`);
            setEvalText('evalLatencyP99', `${formatNumber(latP99, 1)} ms`);
            setEvalText('evalCpuAvg', `${formatNumber(cpuAvg, 1)}%`);
            setEvalText('evalMemAvg', `${formatNumber(memAvg, 1)}%`);
            setEvalText('evalMemPeak', `${formatNumber(memPeak, 1)}%`);
            setEvalText('evalReplicas', String(replicas));
            setEvalText('evalScaling', String(scalingCount));

            const globalScaling = document.getElementById('scalingEvents');
            if (globalScaling) globalScaling.textContent = String(scalingCount);
            const avgLoad = document.getElementById('avgLoad');
            if (avgLoad) avgLoad.textContent = `${formatNumber(cpuAvg, 1)}%`;

            setEvalStatus('Source: demo (simulé)');
        }

        async function refreshEvaluationMetricsFallback() {
            const trafficRes = await fetchJsonOrNull(`${API_URL}/traffic/status`);
            const containersRes = await fetchJsonOrNull(`${API_URL}/containers/list`);
            const scalingRes = await fetchJsonOrNull(`${API_URL}/scaling/history?limit=50`);

            if (!trafficRes.ok && !containersRes.ok && !scalingRes.ok) {
                const demo = loadDemoMetricsEnabled();
                if (demo) {
                    renderDemoEvaluationMetrics();
                    return;
                }
                setEvalStatus('Source: fallback (erreur de connexion)');
                return;
            }

            let jobs = (trafficRes.data && trafficRes.data.jobs) ? trafficRes.data.jobs : [];
            let job = null;
            if (currentTrafficJobId && Array.isArray(jobs)) {
                job = jobs.find(j => j && j.id === currentTrafficJobId) || null;
            }
            if (!job) {
                job = pickLatestJob(jobs);
            }

            if (job && !currentTrafficJobId) {
                currentTrafficJobId = job.id;
                const elJobId = document.getElementById('trafficJobId');
                if (elJobId) elJobId.textContent = currentTrafficJobId;
            }

            let throughputText = '-';
            let errorRateText = '-';
            if (job) {
                const startedMs = parseIsoToMs(job.started_at);
                const stoppedMs = parseIsoToMs(job.stopped_at);
                const endMs = job.running ? Date.now() : (stoppedMs || Date.now());
                const elapsedS = startedMs ? Math.max(0.001, (endMs - startedMs) / 1000.0) : null;
                const sent = Number(job.sent || 0);
                const errors = Number(job.errors || 0);
                if (elapsedS) {
                    throughputText = `${formatNumber(sent / elapsedS, 2)} rps`;
                }
                const total = sent + errors;
                errorRateText = total > 0 ? `${formatNumber((errors / total) * 100.0, 2)}%` : '0.00%';
            }

            let cpuAvgText = '-';
            let memAvgText = '-';
            let memPeakText = '-';
            let replicasText = '-';

            const containers = (containersRes.data && containersRes.data.containers) ? containersRes.data.containers : [];
            if (Array.isArray(containers)) {
                const names = containers.map(c => c && c.name).filter(Boolean);
                replicasText = String(names.filter(n => String(n).includes('_replica_')).length);

                const limitNames = names.slice(0, 20);
                const metricFetches = await Promise.all(limitNames.map(n => fetchJsonOrNull(`${API_URL}/container/${encodeURIComponent(n)}/metrics`)));
                const lastCpu = [];
                const lastMem = [];
                metricFetches.forEach(r => {
                    if (!r || !r.ok || !Array.isArray(r.data) || r.data.length === 0) return;
                    const last = r.data[r.data.length - 1];
                    const cpu = Number(last && last.cpu_percent);
                    const mem = Number(last && last.memory_percent);
                    if (Number.isFinite(cpu)) lastCpu.push(cpu);
                    if (Number.isFinite(mem)) lastMem.push(mem);
                    try {
                        r.data.forEach(m => {
                            const mp = Number(m && m.memory_percent);
                            if (Number.isFinite(mp)) memPeakText = formatNumber(Math.max(Number(memPeakText === '-' ? 0 : memPeakText), mp), 1) + '%';
                        });
                    } catch (e) {
                    }
                });

                if (lastCpu.length > 0) {
                    const avg = lastCpu.reduce((a, b) => a + b, 0) / lastCpu.length;
                    cpuAvgText = `${formatNumber(avg, 1)}%`;
                }
                if (lastMem.length > 0) {
                    const avg = lastMem.reduce((a, b) => a + b, 0) / lastMem.length;
                    memAvgText = `${formatNumber(avg, 1)}%`;
                }
            }

            let scalingCountText = '-';
            if (scalingRes.ok) {
                const hist = (scalingRes.data && scalingRes.data.history) ? scalingRes.data.history : [];
                if (Array.isArray(hist)) scalingCountText = String(hist.length);
            }

            setEvalText('evalThroughput', throughputText);
            setEvalText('evalErrorRate', errorRateText);
            setEvalText('evalLatencyMean', '-');
            setEvalText('evalLatencyP95', '-');
            setEvalText('evalLatencyP99', '-');
            setEvalText('evalCpuAvg', cpuAvgText);
            setEvalText('evalMemAvg', memAvgText);
            setEvalText('evalMemPeak', memPeakText === '-' ? '-' : memPeakText);
            setEvalText('evalReplicas', replicasText);
            setEvalText('evalScaling', scalingCountText);

            const globalScaling = document.getElementById('scalingEvents');
            if (globalScaling && scalingCountText !== '-') globalScaling.textContent = scalingCountText;
            const avgLoad = document.getElementById('avgLoad');
            if (avgLoad && cpuAvgText !== '-') avgLoad.textContent = cpuAvgText;

            setEvalStatus('Source: fallback (latences nécessitent rebuild main)');
        }

        async function refreshEvaluationMetrics() {
            try {
                const demo = loadDemoMetricsEnabled();
                if (demo) {
                    renderDemoEvaluationMetrics();
                    return;
                }

                const url = currentTrafficJobId ? `${API_URL}/metrics/summary?traffic_id=${encodeURIComponent(currentTrafficJobId)}` : `${API_URL}/metrics/summary`;
                const response = await fetch(url);
                if (!response.ok) {
                    if (response.status === 404) {
                        await refreshEvaluationMetricsFallback();
                        return;
                    }
                    setEvalStatus(`Source: backend (${response.status})`);
                    return;
                }

                const summary = await response.json();

                const traffic = summary.traffic || {};
                const resources = summary.resources || {};
                const scaling = summary.scaling || {};

                const tput = (traffic.throughput_rps !== undefined && traffic.throughput_rps !== null) ? `${formatNumber(traffic.throughput_rps, 2)} rps` : '-';
                const errRate = (traffic.error_rate_percent !== undefined && traffic.error_rate_percent !== null) ? `${formatNumber(traffic.error_rate_percent, 2)}%` : '-';
                const latMean = (traffic.latency_mean_ms !== undefined && traffic.latency_mean_ms !== null) ? `${formatNumber(traffic.latency_mean_ms, 1)} ms` : '-';
                const latP95 = (traffic.latency_p95_ms !== undefined && traffic.latency_p95_ms !== null) ? `${formatNumber(traffic.latency_p95_ms, 1)} ms` : '-';
                const latP99 = (traffic.latency_p99_ms !== undefined && traffic.latency_p99_ms !== null) ? `${formatNumber(traffic.latency_p99_ms, 1)} ms` : '-';
                const cpuAvg = (resources.cpu_avg_percent !== undefined && resources.cpu_avg_percent !== null) ? `${formatNumber(resources.cpu_avg_percent, 1)}%` : '-';
                const memAvg = (resources.memory_avg_percent !== undefined && resources.memory_avg_percent !== null) ? `${formatNumber(resources.memory_avg_percent, 1)}%` : '-';
                const memPeak = (resources.memory_peak_percent !== undefined && resources.memory_peak_percent !== null) ? `${formatNumber(resources.memory_peak_percent, 1)}%` : '-';
                const replicas = (resources.replicas_current !== undefined && resources.replicas_current !== null) ? String(resources.replicas_current) : '-';
                const scalingCount = (scaling.events_last_50 !== undefined && scaling.events_last_50 !== null) ? String(scaling.events_last_50) : '-';

                const elThroughput = document.getElementById('evalThroughput');
                if (elThroughput) elThroughput.textContent = tput;
                const elErr = document.getElementById('evalErrorRate');
                if (elErr) elErr.textContent = errRate;
                const elLatMean = document.getElementById('evalLatencyMean');
                if (elLatMean) elLatMean.textContent = latMean;
                const elLat95 = document.getElementById('evalLatencyP95');
                if (elLat95) elLat95.textContent = latP95;
                const elLat99 = document.getElementById('evalLatencyP99');
                if (elLat99) elLat99.textContent = latP99;
                const elCpu = document.getElementById('evalCpuAvg');
                if (elCpu) elCpu.textContent = cpuAvg;
                const elMem = document.getElementById('evalMemAvg');
                if (elMem) elMem.textContent = memAvg;
                const elMemPeak = document.getElementById('evalMemPeak');
                if (elMemPeak) elMemPeak.textContent = memPeak;
                const elReps = document.getElementById('evalReplicas');
                if (elReps) elReps.textContent = replicas;
                const elScaling = document.getElementById('evalScaling');
                if (elScaling) elScaling.textContent = scalingCount;

                const globalScaling = document.getElementById('scalingEvents');
                if (globalScaling) globalScaling.textContent = scalingCount;
                const avgLoad = document.getElementById('avgLoad');
                if (avgLoad && resources.cpu_avg_percent !== undefined && resources.cpu_avg_percent !== null) {
                    avgLoad.textContent = `${formatNumber(resources.cpu_avg_percent, 1)}%`;
                }
                setEvalStatus('Source: backend /metrics/summary');
            } catch (e) {
                try {
                    await refreshEvaluationMetricsFallback();
                } catch (e2) {
                }
            }
        }

        async function refreshGraph() {
            try {
                const response = await fetch(`${API_URL}/graph/export`);
                const data = await response.json();
                const g = (data && Object.prototype.hasOwnProperty.call(data, 'graph')) ? data.graph : data;
                if (typeof g === 'string') {
                    try {
                        graphData = JSON.parse(g);
                    } catch (e) {
                        graphData = null;
                        showAlert('graphAlert', `❌ Graphe invalide (JSON): ${e.message}`, 'error');
                    }
                } else {
                    graphData = g;
                }
                try {
                    const nNodes = (graphData && Array.isArray(graphData.nodes)) ? graphData.nodes.length : 0;
                    const nLinks = (graphData && Array.isArray(graphData.links)) ? graphData.links.length : 0;
                    setGraphStatus(`Graphe: ${nNodes} nodes, ${nLinks} liens`);
                    if (nNodes === 0) {
                        showAlert('graphAlert', '⚠️ Graphe vide: /graph/export ne renvoie aucun node. Vérifie que des conteneurs sont détectés côté orchestrateur.', 'error');
                    }
                } catch (e) {
                }
                drawGraph();
            } catch (e) {
                showAlert('graphAlert', `❌ Erreur chargement graphe: ${e.message}`, 'error');
            }
        }

        function setGraphMode(mode) {
            graphMode = mode;
            graphLinkFrom = null;
            if (mode === 'select') {
                setGraphStatus('Mode: sélection');
                updateGraphActionsUI();
                return;
            }
            if (mode === 'add_link') {
                setGraphStatus('Mode: + lien (clique source puis cible)');
                updateGraphActionsUI();
                return;
            }
            if (mode === 'remove_link') {
                setGraphStatus('Mode: - lien (clique source puis cible)');
                updateGraphActionsUI();
                return;
            }
        }

        function setGraphStatus(text) {
            const el = document.getElementById('graphStatus');
            if (el) el.textContent = text;
        }

        function getGraphRelationType() {
            const ctxEl = document.getElementById('graphContextRelationType');
            if (ctxEl && ctxEl.value) return ctxEl.value;
            const el = document.getElementById('graphRelationType');
            return el ? el.value : 'depends_on';
        }

        function syncGraphRelationTypeFromContext() {
            const ctxEl = document.getElementById('graphContextRelationType');
            const toolbarEl = document.getElementById('graphRelationType');
            if (ctxEl && toolbarEl) {
                toolbarEl.value = ctxEl.value;
            }
        }

        function hideGraphContextMenu() {
            const menu = document.getElementById('graphContextMenu');
            if (menu) menu.style.display = 'none';
            graphContextOpen = false;
        }

        function showGraphContextMenuAt(clientX, clientY) {
            const menu = document.getElementById('graphContextMenu');
            if (!menu) return;

            const pad = 10;
            menu.style.display = 'block';
            menu.style.left = `${clientX + pad}px`;
            menu.style.top = `${clientY + pad}px`;

            const rect = menu.getBoundingClientRect();
            let left = clientX + pad;
            let top = clientY + pad;
            if (left + rect.width > window.innerWidth - 8) {
                left = Math.max(8, window.innerWidth - rect.width - 8);
            }
            if (top + rect.height > window.innerHeight - 8) {
                top = Math.max(8, window.innerHeight - rect.height - 8);
            }
            menu.style.left = `${left}px`;
            menu.style.top = `${top}px`;

            graphContextOpen = true;
        }

        function updateGraphContextMenuUI() {
            const titleEl = document.getElementById('graphContextTitle');
            const nodeActions = document.getElementById('graphContextNodeActions');
            const edgeActions = document.getElementById('graphContextEdgeActions');
            const ctxTypeEl = document.getElementById('graphContextRelationType');

            if (ctxTypeEl) {
                const toolbarEl = document.getElementById('graphRelationType');
                if (toolbarEl && ctxTypeEl.value !== toolbarEl.value) {
                    ctxTypeEl.value = toolbarEl.value;
                }
                if (!ctxTypeEl.dataset.bound) {
                    ctxTypeEl.addEventListener('change', syncGraphRelationTypeFromContext);
                    ctxTypeEl.dataset.bound = '1';
                }
            }

            if (selectedNodeId) {
                if (titleEl) titleEl.textContent = `Conteneur: ${selectedNodeId}`;
                if (nodeActions) nodeActions.style.display = 'flex';
                if (edgeActions) edgeActions.style.display = 'none';
                return;
            }

            if (selectedEdge) {
                if (titleEl) titleEl.textContent = `Lien: ${selectedEdge.from} → ${selectedEdge.to}`;
                if (nodeActions) nodeActions.style.display = 'none';
                if (edgeActions) edgeActions.style.display = 'flex';
                return;
            }

            if (titleEl) titleEl.textContent = 'Sélection';
            if (nodeActions) nodeActions.style.display = 'none';
            if (edgeActions) edgeActions.style.display = 'none';
        }

        function startAddLinkFromSelected() {
            if (!selectedNodeId) {
                showAlert('graphAlert', "Sélectionne d'abord un conteneur", 'error');
                return;
            }
            graphMode = 'add_link';
            graphLinkFrom = String(selectedNodeId);
            setGraphStatus(`Mode: + lien (source=${graphLinkFrom}) → clique la cible`);
            updateGraphActionsUI();
            hideGraphContextMenu();
            drawGraph();
        }

        function startRemoveLinkFromSelected() {
            if (!selectedNodeId) {
                showAlert('graphAlert', "Sélectionne d'abord un conteneur", 'error');
                return;
            }
            graphMode = 'remove_link';
            graphLinkFrom = String(selectedNodeId);
            setGraphStatus(`Mode: - lien (source=${graphLinkFrom}) → clique la cible`);
            updateGraphActionsUI();
            hideGraphContextMenu();
            drawGraph();
        }

        async function createContainerLinkedFromSelected() {
            if (!selectedNodeId) {
                showAlert('graphAlert', "Sélectionne d'abord un conteneur", 'error');
                return;
            }

            const suggested = `worker_${Math.floor(Math.random() * 10000)}`;
            const name = prompt('Nom du conteneur à créer:', suggested);
            if (!name) return;

            const type = getGraphRelationType();
            try {
                const response = await fetch(`${API_URL}/container/create`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name, image: 'orchestrator-worker', env: {}})
                });

                const result = await response.json();
                if (!response.ok) {
                    showAlert('graphAlert', `❌ Erreur création: ${result.error || 'create failed'}`, 'error');
                    return;
                }

                await addLinkFromGraph(String(selectedNodeId), String(name), type);
                showAlert('graphAlert', `✅ Conteneur créé et relié: ${selectedNodeId} → ${name} (${type})`, 'success');
                await refreshContainers();
                await updateMonitorSelect();
                await refreshGraph();
                hideGraphContextMenu();
            } catch (e) {
                showAlert('graphAlert', `❌ Erreur: ${e.message}`, 'error');
            }
        }

        async function createWorkerFromGraph() {
            const suggested = `worker_${Math.floor(Math.random() * 10000)}`;
            const name = prompt('Nom du worker à créer:', suggested);
            if (!name) return;

            try {
                const response = await fetch(`${API_URL}/container/create`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name, image: 'orchestrator-worker', env: {}})
                });

                const result = await response.json();
                if (!response.ok) {
                    showAlert('graphAlert', `❌ Erreur création: ${result.error || 'create failed'}`, 'error');
                    return;
                }

                showAlert('graphAlert', `✅ Worker créé: ${name}`, 'success');
                await refreshContainers();
                await updateMonitorSelect();
                await refreshGraph();
                hideGraphContextMenu();
            } catch (e) {
                showAlert('graphAlert', `❌ Erreur: ${e.message}`, 'error');
            }
        }

        async function deleteSelectedFromGraph() {
            if (!selectedNodeId) {
                showAlert('graphAlert', 'Erreur: aucun node sélectionné', 'error');
                return;
            }
            if (selectedNodeId === 'orchestrator_main') {
                showAlert('graphAlert', 'Impossible de supprimer orchestrator_main', 'error');
                return;
            }
            const ok = confirm(`Supprimer le conteneur ${selectedNodeId} ?`);
            if (!ok) return;

            try {
                const response = await fetch(`${API_URL}/container/${encodeURIComponent(selectedNodeId)}/remove`, {
                    method: 'DELETE'
                });

                const result = await response.json();
                if (!response.ok) {
                    showAlert('graphAlert', `❌ Erreur suppression: ${result.error || 'remove failed'}`, 'error');
                    return;
                }

                selectedNodeId = null;
                selectedEdge = null;
                showAlert('graphAlert', '🗑️ Conteneur supprimé', 'success');
                await refreshContainers();
                await updateMonitorSelect();
                await refreshGraph();
                hideGraphContextMenu();
            } catch (e) {
                showAlert('graphAlert', `❌ Erreur: ${e.message}`, 'error');
            }
        }

        async function addLinkFromGraph(from, to, type) {
            try {
                const response = await fetch(`${API_URL}/relation/add`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({from, to, type})
                });

                const result = await response.json();
                if (!response.ok) {
                    showAlert('graphAlert', `❌ Erreur ajout lien: ${result.error || 'add failed'}`, 'error');
                    return;
                }

                showAlert('graphAlert', `✅ Lien ajouté: ${from} → ${to} (${type})`, 'success');
                await refreshGraph();
            } catch (e) {
                showAlert('graphAlert', `❌ Erreur: ${e.message}`, 'error');
            }
        }

        async function removeSelectedEdgeFromGraph() {
            if (!selectedEdge) {
                showAlert('graphAlert', 'Erreur: aucun lien sélectionné', 'error');
                return;
            }
            const ok = confirm(`Supprimer le lien ${selectedEdge.from} → ${selectedEdge.to} (${selectedEdge.type}) ?`);
            if (!ok) return;
            await removeLinkFromGraph(selectedEdge.from, selectedEdge.to, selectedEdge.type);
            selectedEdge = null;
            hideGraphContextMenu();
        }

        async function removeLinkFromGraph(from, to, type) {
            try {
                const response = await fetch(`${API_URL}/relation/remove`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({from, to, type})
                });

                const result = await response.json();
                if (!response.ok) {
                    showAlert('graphAlert', `❌ Erreur suppression lien: ${result.error || 'remove failed'}`, 'error');
                    return;
                }

                showAlert('graphAlert', `🗑️ Lien supprimé: ${from} → ${to} (${type || 'any'})`, 'success');
                await refreshGraph();
            } catch (e) {
                showAlert('graphAlert', `❌ Erreur: ${e.message}`, 'error');
            }
        }

        function distancePointToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            if (dx === 0 && dy === 0) {
                const ddx = px - x1;
                const ddy = py - y1;
                return Math.sqrt(ddx * ddx + ddy * ddy);
            }
            const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
            const clamped = Math.max(0, Math.min(1, t));
            const cx = x1 + clamped * dx;
            const cy = y1 + clamped * dy;
            const ddx = px - cx;
            const ddy = py - cy;
            return Math.sqrt(ddx * ddx + ddy * ddy);
        }

        function findNodeAt(x, y) {
            let nearest = null;
            let nearestD2 = Infinity;
            for (const [id, b] of nodeHitBoxes.entries()) {
                if (x >= b.x && x <= (b.x + b.w) && y >= b.y && y <= (b.y + b.h)) {
                    return id;
                }

                // Tolérance: clic près du centre du node
                const cx = Number(b.cx);
                const cy = Number(b.cy);
                if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;
                const dx = x - cx;
                const dy = y - cy;
                const d2 = dx * dx + dy * dy;
                if (d2 < nearestD2) {
                    nearestD2 = d2;
                    nearest = id;
                }
            }

            // Rayon de tolérance
            if (nearest && nearestD2 <= (22 * 22)) {
                return nearest;
            }
            return null;
        }

        function findEdgeAt(x, y) {
            let best = null;
            let bestD = Infinity;
            for (const e of edgeHitLines) {
                const d = distancePointToSegment(x, y, e.x1, e.y1, e.x2, e.y2);
                if (d < bestD) {
                    bestD = d;
                    best = e;
                }
            }
            if (best && bestD <= 8) {
                return {from: best.from, to: best.to, type: best.type};
            }
            return null;
        }

        function drawGraph() {
            const canvas = document.getElementById('graphCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            ensureGraphPositionsLoaded();

            if (!ctx.roundRect) {
                ctx.roundRect = function(x, y, w, h, r) {
                    const radius = Math.max(0, Math.min(r || 0, Math.min(w, h) / 2));
                    this.beginPath();
                    this.moveTo(x + radius, y);
                    this.lineTo(x + w - radius, y);
                    this.arcTo(x + w, y, x + w, y + h, radius);
                    this.lineTo(x + w, y + h - radius);
                    this.arcTo(x + w, y + h, x, y + h, radius);
                    this.lineTo(x + radius, y + h);
                    this.arcTo(x, y + h, x, y, radius);
                    this.lineTo(x, y + radius);
                    this.arcTo(x, y, x + w, y, radius);
                    return this;
                };
            }
            const rect = canvas.getBoundingClientRect();
            canvas.width = Math.max(600, Math.floor(rect.width));
            canvas.height = 420;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!graphData || !graphData.nodes) {
                ctx.fillStyle = '#666';
                ctx.font = '14px sans-serif';
                ctx.fillText('Aucun graphe à afficher', 20, 30);
                return;
            }

            const nodes = graphData.nodes.map(n => n.id ?? n); // node_link_data
            const links = graphData.links || [];

            nodeHitBoxes = new Map();
            edgeHitLines = [];

            // layout en cercle
            const positions = new Map();
            const n = nodes.length || 1;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = Math.min(cx, cy) * 0.65;

            nodes.forEach((id, i) => {
                const angle = (2 * Math.PI * i) / n;
                const key = String(id);
                let p = graphPositions.get(key);
                if (!p) {
                    p = {x: cx + radius * Math.cos(angle), y: cy + radius * Math.sin(angle)};
                    graphPositions.set(key, p);
                }
                positions.set(key, p);
            });

            // arêtes
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            links.forEach(l => {
                const src = String(l.source);
                const tgt = String(l.target);
                const p1 = positions.get(src);
                const p2 = positions.get(tgt);
                if (!p1 || !p2) return;

                const relType = String(l.relation_type || 'depends_on');
                const isSelected = selectedEdge && selectedEdge.from === src && selectedEdge.to === tgt && selectedEdge.type === relType;

                ctx.lineWidth = isSelected ? 3 : 1;
                ctx.strokeStyle = isSelected ? 'rgba(220,53,69,0.85)' : 'rgba(0,0,0,0.35)';
                ctx.fillStyle = isSelected ? 'rgba(220,53,69,0.85)' : 'rgba(0,0,0,0.35)';
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                edgeHitLines.push({
                    x1: p1.x,
                    y1: p1.y,
                    x2: p2.x,
                    y2: p2.y,
                    from: src,
                    to: tgt,
                    type: relType
                });

                // flèche
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const arrowLen = 10;
                const arrowAngle = Math.PI / 7;

                ctx.beginPath();
                ctx.moveTo(p2.x, p2.y);
                ctx.lineTo(p2.x - arrowLen * Math.cos(angle - arrowAngle), p2.y - arrowLen * Math.sin(angle - arrowAngle));
                ctx.lineTo(p2.x - arrowLen * Math.cos(angle + arrowAngle), p2.y - arrowLen * Math.sin(angle + arrowAngle));
                ctx.closePath();
                ctx.fill();
            });

            if (graphShiftLinkFrom && graphShiftLinkPoint) {
                const p1 = positions.get(String(graphShiftLinkFrom));
                if (p1) {
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.strokeStyle = 'rgba(102,126,234,0.9)';
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(graphShiftLinkPoint.x, graphShiftLinkPoint.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // nœuds
            nodes.forEach(id => {
                const p = positions.get(String(id));
                if (!p) return;

                const label = String(id);
                const padX = 10;
                const padY = 6;
                ctx.font = '12px sans-serif';
                const textW = ctx.measureText(label).width;
                const boxW = textW + padX * 2;
                const boxH = 22;

                nodeHitBoxes.set(String(id), {
                    x: p.x - boxW / 2,
                    y: p.y - boxH / 2,
                    w: boxW,
                    h: boxH,
                    cx: p.x,
                    cy: p.y
                });

                const isSelected = selectedNodeId && String(selectedNodeId) === String(id);

                ctx.fillStyle = isSelected ? '#dc3545' : '#667eea';
                ctx.strokeStyle = isSelected ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.15)';
                ctx.beginPath();
                ctx.roundRect(p.x - boxW / 2, p.y - boxH / 2, boxW, boxH, 8);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, p.x, p.y);
            });
        }

        function initGraphInteractions() {
            const canvas = document.getElementById('graphCanvas');
            if (!canvas) return;

            canvas.style.touchAction = 'none';

            const toCanvasPoint = (evt) => {
                const rect = canvas.getBoundingClientRect();
                return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
            };

            canvas.addEventListener('pointerdown', (evt) => {
                if (graphMode !== 'select') return;
                const p = toCanvasPoint(evt);
                const node = findNodeAt(p.x, p.y);
                if (!node) return;

                graphPointerDownPoint = {x: p.x, y: p.y};
                graphPointerDownNodeId = String(node);
                graphSuppressNextClick = false;

                if (evt.shiftKey) {
                    graphShiftLinkFrom = String(node);
                    graphShiftLinkPoint = {x: p.x, y: p.y};
                    graphDragMoved = false;
                    graphSuppressNextClick = true;
                    canvas.setPointerCapture(evt.pointerId);
                    setGraphStatus(`Shift: relier ${node} → ...`);
                    drawGraph();
                    return;
                }

                const b = nodeHitBoxes.get(String(node));
                const centerX = b ? b.cx : p.x;
                const centerY = b ? b.cy : p.y;

                graphDraggingNodeId = String(node);
                graphDragOffset = {x: p.x - centerX, y: p.y - centerY};
                graphDragMoved = false;
                canvas.setPointerCapture(evt.pointerId);
            });

            canvas.addEventListener('pointermove', (evt) => {
                if (graphMode !== 'select') return;
                if (!graphDraggingNodeId && !graphShiftLinkFrom) return;
                const p = toCanvasPoint(evt);

                const threshold = 4;
                if (graphPointerDownPoint) {
                    const dx = p.x - graphPointerDownPoint.x;
                    const dy = p.y - graphPointerDownPoint.y;
                    if ((dx * dx + dy * dy) >= (threshold * threshold)) {
                        graphSuppressNextClick = true;
                    }
                }

                if (graphShiftLinkFrom) {
                    graphShiftLinkPoint = {x: p.x, y: p.y};
                    graphDragMoved = true;
                    drawGraph();
                    return;
                }

                const key = String(graphDraggingNodeId);
                const x = p.x - graphDragOffset.x;
                const y = p.y - graphDragOffset.y;
                graphPositions.set(key, {x, y});
                graphDragMoved = true;
                drawGraph();
            });

            canvas.addEventListener('pointerup', async (evt) => {
                if (graphMode !== 'select') return;
                const p = toCanvasPoint(evt);

                // Fallback: si pointerdown n'a pas accroché, on retente ici (plus robuste selon navigateur)
                if (!graphDraggingNodeId && !graphShiftLinkFrom) {
                    const node = findNodeAt(p.x, p.y);
                    const edge = node ? null : findEdgeAt(p.x, p.y);
                    if (node) {
                        selectedNodeId = String(node);
                        selectedEdge = null;
                        setGraphStatus(`Sélection: node=${selectedNodeId}`);
                        updateGraphActionsUI();
                        drawGraph();
                        updateGraphContextMenuUI();
                        showGraphContextMenuAt(evt.clientX, evt.clientY);
                        graphSuppressNextClick = true;
                        graphPointerDownNodeId = null;
                        graphPointerDownPoint = null;
                        return;
                    }
                    if (edge) {
                        selectedEdge = edge;
                        selectedNodeId = null;
                        setGraphStatus(`Sélection: lien=${edge.from} → ${edge.to} (${edge.type})`);
                        updateGraphActionsUI();
                        drawGraph();
                        updateGraphContextMenuUI();
                        showGraphContextMenuAt(evt.clientX, evt.clientY);
                        graphSuppressNextClick = true;
                        graphPointerDownNodeId = null;
                        graphPointerDownPoint = null;
                        return;
                    }
                }

                if (graphShiftLinkFrom) {
                    const from = String(graphShiftLinkFrom);
                    const to = findNodeAt(p.x, p.y);
                    graphShiftLinkFrom = null;
                    graphShiftLinkPoint = null;
                    drawGraph();

                    if (to && String(to) !== from) {
                        const type = getGraphRelationType();
                        await addLinkFromGraph(from, String(to), type);
                        hideGraphContextMenu();
                    }
                    return;
                }

                if (graphDraggingNodeId) {
                    graphDraggingNodeId = null;
                    if (graphDragMoved) {
                        saveGraphPositions();
                    }
                    // Si c'était un simple clic (pas de drag), ouvrir le menu ici (plus fiable que 'click')
                    if (!graphDragMoved && graphPointerDownNodeId) {
                        selectedNodeId = String(graphPointerDownNodeId);
                        selectedEdge = null;
                        setGraphStatus(`Sélection: node=${selectedNodeId}`);
                        updateGraphActionsUI();
                        drawGraph();
                        updateGraphContextMenuUI();
                        showGraphContextMenuAt(evt.clientX, evt.clientY);
                        graphSuppressNextClick = true;
                    }
                    graphPointerDownNodeId = null;
                    graphPointerDownPoint = null;
                    return;
                }
            });

            canvas.addEventListener('click', async (evt) => {
                if (graphSuppressNextClick) {
                    graphSuppressNextClick = false;
                    if (graphDragMoved) {
                        graphDragMoved = false;
                    }
                    graphPointerDownPoint = null;
                    return;
                }
                const rect = canvas.getBoundingClientRect();
                const x = evt.clientX - rect.left;
                const y = evt.clientY - rect.top;

                const node = findNodeAt(x, y);
                const edge = node ? null : findEdgeAt(x, y);

                if (graphMode === 'add_link') {
                    if (!node) {
                        showAlert('graphAlert', 'Clique un node source', 'error');
                        return;
                    }

                    if (!graphLinkFrom) {
                        graphLinkFrom = node;
                        selectedNodeId = node;
                        selectedEdge = null;
                        setGraphStatus(`Mode: + lien (source=${node}) → clique la cible`);
                        updateGraphActionsUI();
                        drawGraph();
                        hideGraphContextMenu();
                        return;
                    }

                    const from = graphLinkFrom;
                    const to = node;
                    const type = getGraphRelationType();

                    graphLinkFrom = null;
                    await addLinkFromGraph(from, to, type);
                    setGraphMode('select');
                    hideGraphContextMenu();
                    return;
                }

                if (graphMode === 'remove_link') {
                    if (!node) {
                        showAlert('graphAlert', 'Clique un node source', 'error');
                        return;
                    }

                    if (!graphLinkFrom) {
                        graphLinkFrom = node;
                        selectedNodeId = node;
                        selectedEdge = null;
                        setGraphStatus(`Mode: - lien (source=${node}) → clique la cible`);
                        updateGraphActionsUI();
                        drawGraph();
                        hideGraphContextMenu();
                        return;
                    }

                    const from = graphLinkFrom;
                    const to = node;
                    const type = getGraphRelationType();

                    graphLinkFrom = null;
                    await removeLinkFromGraph(from, to, type);
                    setGraphMode('select');
                    hideGraphContextMenu();
                    return;
                }

                if (node) {
                    selectedNodeId = node;
                    selectedEdge = null;
                    setGraphStatus(`Sélection: node=${node}`);
                    updateGraphActionsUI();
                    drawGraph();
                    updateGraphContextMenuUI();
                    showGraphContextMenuAt(evt.clientX, evt.clientY);
                    return;
                }

                if (edge) {
                    selectedEdge = edge;
                    selectedNodeId = null;
                    setGraphStatus(`Sélection: lien=${edge.from} → ${edge.to} (${edge.type})`);
                    updateGraphActionsUI();
                    drawGraph();
                    updateGraphContextMenuUI();
                    showGraphContextMenuAt(evt.clientX, evt.clientY);
                    return;
                }

                selectedNodeId = null;
                selectedEdge = null;
                setGraphStatus('Mode: sélection');
                updateGraphActionsUI();
                drawGraph();
                hideGraphContextMenu();
            });

            document.addEventListener('click', (e) => {
                const menu = document.getElementById('graphContextMenu');
                if (!menu || !graphContextOpen) return;
                if (e.target === canvas) return;
                if (menu.contains(e.target)) return;
                hideGraphContextMenu();
            }, true);
        }

        function updateGraphActionsUI() {
            const actions = document.getElementById('graphActions');
            if (!actions) return;
            actions.style.display = 'none';
            updateGraphContextMenuUI();
        }

        // Afficher une alerte
        function showAlert(elementId, message, type) {
            const alert = document.getElementById(elementId);
            if (!alert) return;
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            setTimeout(() => alert.textContent = '', 5000);
        }

        // Initialisation
        window.onload = function() {
            refreshContainers();
            updateMonitorSelect();
            if (typeof initMetricsChart === 'function') {
                initMetricsChart();
            }
            refreshGraph();
            initGraphInteractions();
            updateGraphActionsUI();

            refreshEvaluationMetrics();

            try {
                const toggle = document.getElementById('demoMetricsToggle');
                if (toggle) {
                    toggle.checked = loadDemoMetricsEnabled();
                    toggle.addEventListener('change', () => {
                        setDemoMetricsEnabled(!!toggle.checked);
                        refreshEvaluationMetrics();
                    });
                }
            } catch (e) {
            }
            
            // Actualisation automatique
            setInterval(refreshContainers, 10000);
            setInterval(refreshTrafficStatus, 2000);
            setInterval(refreshGraph, 5000);
            setInterval(refreshEvaluationMetrics, 2000);
        };
    </script>
</body>
</html>

